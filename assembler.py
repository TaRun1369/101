# -*- coding: utf-8 -*-
"""Assembler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rnG1bZd21I2ccEHLMLJzM6d_wahLx4iI
"""

OPTAB = {
    "STOP": "(IS,00)",
    "ADD": "(IS,01)",
    "SUB": "(IS,02)",
    "MULT": "(IS,03)",
    "MOVER": "(IS,04)",
    "MOVEM": "(IS,05)",
    "COMP": "(IS,06)",
    "BC": "(IS,07)",
    "DIV": "(IS,08)",
    "READ": "(IS,09)",
    "PRINT": "(IS,10)",
    # "DC": "DL,01",
    # "DS": "DL,02",
    # "START": "AD,01",
    # "END": "AD,02",
    # "ORIGIN": "AD,03",
    # "EQU": "AD,04",
    # "LTORG": "AD,05",
}

REG = {
    "AREG": "(1)",
    "BREG": "(2)",
    "CREG": "(3)",
    "DREG": "(4)",
}

CC = {
    "LT": "(1)",
    "LE": "(2)",
    "EQ": "(3)",
    "GT": "(4)",
    "GE": "(5)",
    "ANY": "(6)"
}



class pass1 :
    def __init__(self):
        self.symTab = [] # ek symbol table lagega as list of list
        self.litTab = [] # ek literal table lagega as list of list
        #self.litTab is a list of lists, where each inner list represents a literal and its associated information.
        self.poolTab = [0] # ek list he hai 0 ka matlab initial index is set to 0??(doubtful)
        self.lc = 0 # ig counter dekhte aage - location counter??(doubtful)
        self.litIndex = 0
        self.poolIndex = 0
    #function to update symbol table
    def updateSymTab(self,pair):#pair mein symbol aur uska address hai
        for i in self.symTab:# i bhi ek list hai jiske 0th position pe ek symbol hai agar match hua symbol toh i ke 1th pe address dal denge nhi toh alag se apprend kar denge symtab mein
            if i[0] == pair[0]:
                i[1] = pair[1]
                return
        else:
            self.symTab.append(pair)

    #function to get symbol address
    def getSymLocCoun(self,symbol):
        for i in self.symTab:
            if i[0] == symbol:
                return i[1]
        else:
            return -1

    # function for getting symbol position
    def getSymPos(self,symbol): # symbol shyad string hai
        for pos,val in enumerate(self.symTab):# enumerate usko aisa couter lagayga ki pos mein index aaye aur val mein wo inner list uss index ki
            if val[0] == symbol:# taki jaha symbol mila wo wala index do
                return pos
        else:
          return -1
    #function for actual process ig
    def process(self):
        with open("input1.txt","r") as file:
            data = file.readlines()

            for line in data:
                word = line.replace("\n" , "").split("\t")# \t pe todega aur new line ko replace karega by khali character
               # print(word)
                if word[0] != '' and word[0]!= 'START': #word[0] is label or symbol
                    # manje label pada hai waha kyuki \n ko replace kiya
                    pair = [word[0],self.lc]
                    self.updateSymTab(pair)
                # word[1] is opcode or directive
                # word[2] is operand or parameter
                if word[0] == 'START': #word[1] agar start hai toh print karo uska corresponding jo bhi rehta with its location counter
                    self.lc = int(word[1])
                    print(f"(AD,01)\t(C,{self.lc})")# f is used for curly bracs
                    #naya feature hai jismein embedded rakh sakte data

                if word[1] == 'DC':# define constant agar raha
                    self.lc+=1 # DC use hota space reserve karne ke liye for single constant
                    constant = word[2][1:-1] # operand - word[2] ke andar slicing ki hai starts from second character (index 1) exclusing last character that is (index -1 , counted backwards)
                    print(f"(DL,01)\t(C,{constant})") # wo slicing se enclosing character nikal rahe bas

                if word[1] == 'LTORG' or word[1] == 'END': # LTORG aane pe apan assign karna start kar dete wahi ho raha yaha bhi
                    for i in range(self.poolIndex,self.litIndex):
                        # This loop iterates over the range of indices [self.poolIndex, self.poolIndex + 1, ..., self.litIndex - 1]
                        self.litTab[i][1] = self.lc # littab ke inner loop ke 1st pe address hai literal ka
                        self.lc+=1 # as each literal occupy one memory location

                        value = int(self.litTab[i][0].replace('=','').replace("'","")) # It typically stores the literal numeric value.

                        print(f"(DL,01)\t(C,{value})")

                    self.poolTab.append(self.poolIndex)
                    self.poolIndex = self.litIndex

                    if word[0] == 'END':
                        print('(AD,02')

                if word[1] == 'DS': # storage declare / reserve karne ke liye rehta ye
                    constant = int(word[2]) # simple.txt dekh 3 hai toh string 3 ko int 3 kar raha bas
                    self.lc += constant # location 3 se aage badh jayegi kyuki wo reserved hai
                    print(f'(DL,02)\t(C,{constant})')

                if word[1] == 'ORIGIN':
                    self.lc = int(word[2]) # lc set hoga as origin hai jo location diya hai origin ke aage uspe
                    print(f'(AD,03)\t(C,{self.lc})')

                    if word[2].find('+') != -1:
                        exp = word[2].split('+')
                        self.lc += self.getSymLocCoun(exp[0]) + int(exp[1])

                    elif word[2].find('-') != -1:
                        exp = word[2].split('-')
                        self.lc += self.getSymLocCoun(exp[0]) - int(exp[1])

                if word[1] == 'EQU':
                    if word[2].find('+') != None:
                        exp = word[2].split('+')
                        index = self.getSymLocCoun(exp[0]) + int(exp[1]) # exp[0] mein operand hai (ex - D	EQU	A+1) toh exp[0] = 'A' and exp[1] = '1'
                        self.updateSymTab([word[0],index]) # ye ab update kar dega symbol mein uska new address
                        sym_Index = self.getSymPos(exp[0]) + 1
                        print(f"(AD,04)(S,{sym_Index}) + {exp[1]}")

                if OPTAB.get(word[1]) != None: # OPTAB is operation table
                    code = OPTAB.get(word[1]) + "\t" # OPTAB.get(word[1]) retrieves the value associated with the opcode from the OPTAB.
                    j = 2 # loop will start processing operands from the third element
                    # kyuki the opcode is at word[1], and operands start from word[2]
                    while(j<len(word)):
                        if REG.get(word[j]) != None: # if it is register
                            code += REG.get(word[j]) + str("\t")
                        elif CC.get(word[j]) != None: # if it is condition code
                            code += CC.get(word[j]) + str('\t')
                        elif word[j].find('=') != -1:
                            # If the operand contains '=', it is considered a literal.
                            # The literal is appended to the literal table (self.litTab),
                            # and its placeholder in the code is added as (L,self.litIndex).
                            self.litTab.append([word[j],-1])
                            word[j] = word[j].replace('=','').replace("'","")
                            self.litIndex += 1
                            code += f"(L,{self.litIndex})"
                            pass
                        else:
                            #it is assumed to be a symbol
                            if self.getSymLocCoun(word[j]) == -1: # agar symtable mein nhi hai toh address -1
                                pair = [word[j],-1]
                                self.updateSymTab(pair)

                            const = self.getSymPos(word[j]) + 1
                            code += f"(S,{const})"

                        j+=1 # j is incremented to move to the next operand in the word list

                    self.lc+=1 #The Location Counter (self.lc) is incremented after processing the entire instruction.
                    print(code)

            print("Symtab" , end = "")
            print(self.symTab)
            print("Literal Tab: ", end = " ")
            print(self.litTab)
            print("PoolTab", end="")
            print(self.poolTab)

            with open("Symtab.txt", "w") as file:
                str1 = ""
                for x, val in enumerate(self.symTab):
                    str1 = str(x)+"\t"+str(val) + "\n"
                    file.write(str1)

                file.close()

            with open("Littab.txt", "w") as file:
                str1 = ""
                for x, val in enumerate(self.litTab):
                    str1 = str(x)+"\t"+str(val) + "\n"
                    file.write(str1)

                file.close()

            with open("Pooltab.txt", "w") as file:
                str1 = ""
                for x, val in enumerate(self.poolTab):
                    str1 = str(x)+"\t"+str(val) + "\n"
                    file.write(str1)

                file.close()


test = pass1()
test.process()

class Pass2:
    def __init__(self):
        self.symtab = [] # list hai  jismein symbol hai
        self.littab = [] # list hai jismein literal hai
       # pass

    def readFiles(self):
        with open("Symtab.txt", "r") as File:
            data = File.readlines()
            for line in data:
                word = line.split()
                # print(word) --> # ['0', "['X',", '9]']
                self.symtab.append(int(word[2][:-1]))
        with open("Littab.txt", "r") as File:
            data = File.readlines()
            for line in data:
                word = line.split()
                self.littab.append(int(word[2][:-1]))

    def LiteralORSymbol(self, w):
        index = int(w[3:-1])
        # print(w)
        # eg w = (L,1)
        if w.find('L') != -1:  # agar literal hai toh
            return (self.littab[index-1])
        else: # agar Symbol hai toh
            return (self.symtab[index -1])

    def process(self):
        with open("IC.txt", "r") as file:
            data = file.readlines()
            for line in data:

                word = line.replace("\n", "").strip().split()
                # print(word) # --> #['(AD,01)', '(C,201)']
                if word[0].find('AD') != -1 or word[0].find('DL,02') != -1:
                    print()
                elif word[0].find("DL,01") != -1: # eg - (DL,01)	(C,2)
                    # print(word[1])
                    print(f"00\t0\t{word[1][3:-1]}") # word[1][3:-1] = 2
                    pass
                elif word[0].find('IS,00') != -1:  #stop
                    print("00\t0\t000")
                elif word[0].find('IS,10') != -1: #print
                    code = self.LiteralORSymbol(word[1])
                    print(f"10\t0\t{code}")
                elif word[0].find('IS') != -1:
                    # print(word[0]) # --> (IS,05)
                    # print(word[0][4:-1]) # --> 04
                    # print(word[1]) # --> (1)
                    # print(word[1][1]) # --> 1
                    code1 = word[0][4:-1]
                    code2 = word[1][1]
                    code3 = self.LiteralORSymbol(word[2])
                    print(f"{code1}\t{code2}\t{code3}")
                else:
                    print()

            file.close()


test = Pass2()
test.readFiles()
test.process()