# -*- coding: utf-8 -*-
"""MACROPass1Pass2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vqf-_N5jH1VcsVFrYBJZ9LeNGKcil0nf
"""

class pass1macro:
    def __init__(self) -> None:
        self.count_pp = 0 #Counter for positional parameters.
        self.count_kp = 0 # Counter for keyword parameters.
        self.mnt = "" # macro name table
        self.pntab = "" #program name table
        self.mdtp = 1 # macro definition table pointer
        self.kptp = 1 # keyword parameter default table pointer
        self.kpdt = "" # keyword parameter default table
        self.macro_count = 0 #Counter for the number of macros encountered
        self.ic = "" # intermidiate code
        self.mdt = "" # macro def table
        pass

    def process(self):
        NEXT_MACRO = False # True, it means that the code is currently processing a line within a macro definition.
        IS_START = False
        with open("input.asm","r") as file:
            data = file.readlines()
            for lines in data:
                if lines.find('START') != -1 or IS_START == True:
                    self.ic += lines
                    IS_START = True

                else:
                    word = lines.replace("&","").replace(",","").split()
                    if NEXT_MACRO == True: # yaha macro chalu hua tab aaya wo
                        self.count_kp = 0 # reset to 0 as new macro
                        self.count_pp = 0
                        macro_name = word[0] # macro ka  naam liya
                        self.pntab += f"{macro_name}\t" # pntab mein macro ka naam dala
                        for i in range(1,len(word)):
                            if word[i].find("=") != -1: #  used to identify whether the parameter is a keyword parameter with a default value.
                                self.count_kp += 1 # counter badhaya
                                parameter_name = word[i].partition("=")[0] # partition se 3 part honge  uska first part by [0]
                                given_name = word[i].partition("=")[2]  # similarly uska 3rd part by [2]
                                self.pntab +=parameter_name + "\t"
                                self.kpdt += f"{parameter_name}\t{given_name}\n"
                            else: # matlab positional parameter hai
                                # ismein = nhi hai toh todne ki jarurat nhi direct dalo
                                self.pntab += word[i] + "\t"
                                self.count_pp += 1  # counter badhaya
                        self.pntab += "\n"
                        self.mnt += f"{macro_name}\t{self.count_pp}\t{self.count_kp}\t{self.mdtp}\t{self.kptp}\n"
                        self.kptp += self.count_kp
                        NEXT_MACRO = False # khatam hua macro definition false kar do

                    elif word[0] == 'MACRO': # agar macro mila matlab next lin se chalu hoga toh true kar do
                        self.macro_count += 1 # counter toh badhega
                        NEXT_MACRO = True
                        pass
                    else:
                        string  = word[0] + "\t" # mnemonic or opcode aaya ismein
                        parameters = self.pntab.split('\n')[self.macro_count-1].split() # pehle line mein split kiya
                        # fir [] used to access current macro
                        # split() use hota indiviusal parameter names mein todne ke liye
                        for i in range(1,len(word)):
                            if word[i].find('=') != -1: # keyword parameter raha toh ye
                                string += word[i] + "\t"
                            else: # positional parameter raha toh ye
                                index = parameters.index(word[i]) # find position of parameter named word[i]
                                string += f"(P,{index})\t" # P for positional and uska index
                        self.mdtp += 1 # keep trach of macro def table
                        string += "\n"
                        self.mdt += string

        print("*"*8 + "MDT" + "*"*8)
        print(self.mdt)
        print("*"*8 + "MNT" + "*"*8)
        print(self.mnt)
        print("*"*8 + "PNTAB" + "*"*8)
        print(self.pntab)
        print("*"*8 + "KPDT" + "*"*8)
        print(self.kpdt)
        print("*"*8 + "IC" + "*"*8)
        print(self.ic)

        with open('mdt.txt' , "w") as file:
            file.write(self.mdt)

        with open("mnt.txt" , "w") as file:
            file.write(self.mnt)

        with open("pntab.txt" , "w") as file:
            file.write(self.pntab)

        with open("kpdt.txt" , "w") as file:
            file.write(self.kpdt)

        with open("ic.txt" , "w") as file :
            file.write(self.ic)


test = pass1macro()
test.process()

class pass2macro:
    def __init__(self) -> None:
        self.mnt = {} # Stores information about macros (number of parameters, starting positions)
        self.pntab ={} # Stores information about macros (number of parameters, starting positions)
        self.kpdt = {} # Stores default values for keyword parameters.
        self.output = "" # Accumulates the lines of the final expanded code.
        self.aptab = {} # Stores values of arguments for the current macro call being processed.
        self.current_macro = 0 # Keeps track of the current macro being processed.
        pass

    def readfiles(self):
        # Assuming you are reading from your provided sample files
        with open("mnt.txt", "r") as mntFile:
            for line in mntFile:
                data = line.split()
                macro_name = data[0]
                self.mnt[macro_name] = [int(data[1]), int(data[2]), int(data[3]), int(data[4])]

        with open("pntab.txt", "r") as pntabFile:
            for line in pntabFile:
                data = line.split()
                macro_name = data[0]
                self.pntab[macro_name] = data[1:]

        with open("kpdt.txt", "r") as kpdtFile:
            for line in kpdtFile:
                data = line.split()
                self.kpdt[data[0]] = data[1]

        print("PNTAB" , self.pntab)
        print("KPTAB" ,self.kpdt)
        print("MNT" , self.mnt)

        pass

    def process(self):
        icFile = open("ic.txt","r")

        mdtfile = open("mdt.txt","r")

        for lines in icFile:
            word = lines.replace(",","").replace("&","").split()
            if word[0] not in self.mnt.keys():  #  it means the line is not a macro call,
                self.output+=lines
            else: # macro call hai ye
                self.current_macro += 1
                self.aptab = {} # empty dictionary banaya
                MNT = self.mnt[word[0]] # word[0] is macro name and mnt ke andar bheja toh wo list deta contanining info about macro
                pp = MNT[0] # list ka 0th is no. of pp
                kp = MNT[1] # no . of kp
                for i in range(1,pp + 1):
                    self.aptab[i] = word[i] # assigns values of pps from word list to aptab psoitions


                aptabIdx = pp+1
                for i in self.pntab[word[0]]:
                  if i in self.kpdt:
                    self.aptab[aptabIdx] = self.kpdt[i]
                    aptabIdx+=1

                print(self.aptab)
                for i in range(pp + 1,min(pp + kp + 1, len(word))): # range over kps of macro
                    if word[i].partition("=")[2] == '': # if empty string
                        self.aptab[i] = self.kpdt[word[i].partition("=")[0]] # assigns default value
                    else:
                        self.aptab[i] = word[i].partition('=')[2] # assigns value specifies in the macro call after =

                for lines in mdtfile:
                    wordMDT = lines.split() # split inn list of words
                    if wordMDT[0] != 'MEND': # that is macr odef is not end
                        self.output += wordMDT[0] + "\t" # Adds the mnemonic or operation code from the Macro Definition Table to the output.

                        for i in range(1, len(wordMDT)):
                            if wordMDT[i].find('=') == -1: # positional hai kya check
                                parameter_index = int(wordMDT[i][3]) # if is true toh paramter index nikalega isse
                                self.output += self.aptab[parameter_index] + "\t" # corresponding arg value from output
                            else: # If false, it adds the parameter as is to the output
                                self.output += wordMDT[i] + "\t"

                        self.output += "\n"

                    else:
                        break
        print(self.output)

test = pass2macro()
test.readfiles()
test.process()

class pass2macro:
    def __init__(self) -> None:
        self.mnt = {} # Stores information about macros (number of parameters, starting positions)
        self.pntab ={} # Stores information about macros (number of parameters, starting positions)
        self.kpdt = {} # Stores default values for keyword parameters.
        self.output = "" # Accumulates the lines of the final expanded code.
        self.aptab = {} # Stores values of arguments for the current macro call being processed.
        self.current_macro = 0 # Keeps track of the current macro being processed.
        pass

    def readfiles(self):
        # Assuming you are reading from your provided sample files
        with open("mnt.txt", "r") as mntFile:
            for line in mntFile:
                data = line.split()
                macro_name = data[0]
                self.mnt[macro_name] = [int(data[1]), int(data[2]), int(data[3]), int(data[4])]

        with open("pntab.txt", "r") as pntabFile:
            for line in pntabFile:
                data = line.split()
                macro_name = data[0]
                self.pntab[macro_name] = data[1:]

        with open("kpdt.txt", "r") as kpdtFile:
            for line in kpdtFile:
                data = line.split()
                self.kpdt[data[0]] = data[1]

        print("PNTAB" , self.pntab)
        print("KPTAB" ,self.kpdt)
        print("MNT" , self.mnt)

        pass

    def process(self):
        icFile = open("ic.txt","r")

        mdtfile = open("mdt.txt","r")

        for lines in icFile:
            word = lines.replace(",","").replace("&","").split()
            if word[0] not in self.mnt.keys():  #  it means the line is not a macro call,
                self.output+=lines
            else: # macro call hai ye
                self.current_macro += 1
                self.aptab = {} # empty dictionary banaya
                MNT = self.mnt[word[0]] # word[0] is macro name and mnt ke andar bheja toh wo list deta contanining info about macro
                pp = MNT[0] # list ka 0th is no. of pp
                kp = MNT[1] # no . of kp
                for i in range(1,pp + 1):
                    self.aptab[i] = word[i] # assigns values of pps from word list to aptab psoitions


                aptabIdx = pp+1
                for i in self.pntab[word[0]]:
                  if i in self.kpdt:
                    self.aptab[aptabIdx] = self.kpdt[i]
                    aptabIdx+=1

                print(self.aptab)
                for i in range(pp + 1,min(pp + kp + 1, len(word))): # range over kps of macro
                    if word[i].partition("=")[2] == '': # if empty string
                        self.aptab[i] = self.kpdt[word[i].partition("=")[0]] # assigns default value
                    else:
                        self.aptab[i] = word[i].partition('=')[2] # assigns value specifies in the macro call after =

                for lines in mdtfile:
                    wordMDT = lines.split() # split inn list of words
                    if wordMDT[0] != 'MEND': # that is macr odef is not end
                        self.output += wordMDT[0] + "\t" # Adds the mnemonic or operation code from the Macro Definition Table to the output.

                        for i in range(1, len(wordMDT)):
                            if wordMDT[i].find('=') == -1: # positional hai kya check
                                parameter_index = int(wordMDT[i][3]) # if is true toh paramter index nikalega isse
                                self.output += self.aptab[parameter_index] + "\t" # corresponding arg value from output
                            else: # If false, it adds the parameter as is to the output
                                self.output += wordMDT[i] + "\t"

                        self.output += "\n"

                    else:
                        break
        print(self.output)

test = pass2macro()
test.readfiles()
test.process()